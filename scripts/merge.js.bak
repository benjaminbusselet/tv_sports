#!/usr/bin/env node

/* eslint-env node */

import fs from "node:fs/promises";
import path from "node:path";
import     #!/usr/bin/env node

/* eslint-env node */

import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

// Chemin du fichier de configuration des sources ICS
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const icsSourcesPath = path.join(__dirname, "../config/icsSources.json");

// Lecture des sources ICS
let icsSources = [];
try {
  const icsSourcesContent = await fs.readFile(icsSourcesPath, "utf8");
  icsSources = JSON.parse(icsSourcesContent);
} catch (err) {
  console.error("Erreur lors de la lecture des sources ICS:", err);
}

const ymd = process.argv[2];
const KEEP = process.argv.includes("--keep");

if (!/^\d{8}$/.test(ymd || "")) {
  console.error("Usage: node scripts/merge.js YYYYMMDD [--keep]");
  process.exit(1);
}

// Normalisation des chaînes de caractères
const norm = (s) =>
  String(s || "")
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();

const tms = (s) => new Date(s).getTime();

// Fenêtre temporelle strictement ±1 heure
const near = (a, b, ms = 60 * 60 * 1000) =>
  a && b && Math.abs(tms(a) - tms(b)) <= ms;

// Vérifie si match un samedi à 17h00 heure de Paris pour Ligues spéciales
const isSat17Paris = (iso) => {
  const p = new Intl.DateTimeFormat("en-GB", {
    timeZone: "Europe/Paris",
    weekday: "short",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  }).formatToParts(new Date(iso));

  const m = Object.fromEntries(p.map((x) => [x.type, x.value]));
  return m.weekday === "Sat" && m.hour === "17";
};

// Fonction utilitaire pour lire les fichiers JSON, retourne [] si absent ou erreur
const tryRead = async (paths) => {
  for (const p of paths) {
    try {
      return JSON.parse(await fs.readFile(p, "utf-8"));
    } catch {}
  }
  return [];
};} from "node:url";

// Chemin du fichier de configuration des sources ICS
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const icsSourcesPath = path.join(__dirname, "../config/icsSources.json");

// Lecture des sources ICS
let icsSources = [];
try {
  const icsSourcesContent = await fs.readFile(icsSourcesPath, "utf8");
  icsSources = JSON.parse(icsSourcesContent);
} catch (err) {
  console.error("Erreur lors de la lecture des sources ICS:", err);
}

const ymd = process.argv[2];
const KEEP = process.argv.includes("--keep");

if (!/^\d{8}$/.test(ymd || "")) {
  console.error("Usage: node scripts/merge.js YYYYMMDD [--keep]");
  process.exit(1);
}

// Normalisation des chaînes de caractères
const norm = (s) =>
  String(s || "")
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, " ")
    .replace(/\s+/g, " ")
    .trim();

const tms = (s) => new Date(s).getTime();

// Fenêtre temporelle strictement ±1 heure
const near = (a, b, ms = 60 * 60 * 1000) =>
  a && b && Math.abs(tms(a) - tms(b)) <= ms;

// Vérifie si match un samedi à 17h00 heure de Paris pour Ligues spéciales
const isSat17Paris = (iso) => {
  const p = new Intl.DateTimeFormat("en-GB", {
    timeZone: "Europe/Paris",
    weekday: "short",
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
  }).formatToParts(new Date(iso));

  const m = Object.fromEntries(p.map((x) => [x.type, x.value]));
  return m.weekday === "Sat" && m.hour === "17";
};

// Fonction utilitaire pour lire les fichiers JSON, retourne [] si absent ou erreur
const tryRead = async (paths) => {
  for (const p of paths) {
    try {
      return JSON.parse(await fs.readFile(p, "utf-8"));
    } catch {}
  }
  return [];
};

// Fonction principale exportée pour pipeline en mémoire
export async function mergeData(ics, epg, teams, ymd) {
  const pData = "public/data";

  // Construction d'un index alias -> nom officiel par compétition
  const idx = {};
  for (const [comp, map] of Object.entries(teams || {})) {
    const m = (idx[comp] = {});
    for (const [team, aliases] of Object.entries(map || {})) {
      m[norm(team)] = team;
      for (const a of aliases || []) m[norm(a)] = team;
    }
  }

  // Mapper un programme EPG à sa chaine, équipes officielles, date
  const mapEpg = (comp, p) => {
    const m = idx[comp] || {};
    const h = m[norm(p.epgHome)],
      a = m[norm(p.epgAway)];
    return h && a ? { ch: p.channel, h, a, st: p.start } : null;
  };

  const out = [];
  for (const ev of ics || []) {
    const comp = ev.competition,
      H = norm(ev.home),
      A = norm(ev.away);

    // Trouve les candidats EPG matching équipes + fenêtre de temps stricte ±1h
    const cand = (epg || [])
      .map((p) => mapEpg(comp, p))
      .filter(Boolean)
      .filter((x) => {
        const same =
          (norm(x.h) === H && norm(x.a) === A) ||
          (norm(x.h) === A && norm(x.a) === H);
        return same && near(ev.start, x.st);
      })
      .sort(
        (x, y) =>
          Math.abs(tms(x.st) - tms(ev.start)) -
          Math.abs(tms(y.st) - tms(ev.start))
      );

    let chan = cand[0]?.ch || "";

    // Traitement spécial pour les événements F1
    if (ev.sport === "f1") {
      // Recherche plus large pour les événements F1
      const f1Candidates = (epg || [])
        .filter((p) => {
          const titleMatch =
            p.title && 
            (p.title.toLowerCase().includes("formule 1") ||
            p.title.toLowerCase().includes("f1") ||
            p.title.toLowerCase().includes("grand prix"));

          // Match temporel approximatif (jusqu'à 2h de différence)
          const timeMatch = near(ev.start, p.start, 120);

          return titleMatch && timeMatch;
        })
        .sort(
          (x, y) =>
            Math.abs(tms(x.start) - tms(ev.start)) -
            Math.abs(tms(y.start) - tms(ev.start))
        );

      // Collecter toutes les chaînes uniques où l'événement est diffusé
      if (f1Candidates.length > 0) {
        const channels = [...new Set(f1Candidates.map((c) => c.channel))];
        ev.broadcasters = channels;
        console.log(
          `F1 event matched: ${ev.title} on ${channels.join(", ")}`
        );
      } else {
        // Pour les événements F1 sans correspondance dans l'EPG, ne pas assigner de diffuseur par défaut
        // mais laisser un tableau vide pour que l'interface puisse le gérer correctement
        ev.broadcasters = [];
        console.log(
          `F1 event not matched in EPG: ${ev.title}, no default broadcasters assigned`
        );
      }
    }

    // Traitement spécial pour les événements F1
    if (ev.sport === "f1") {
      // Recherche plus large pour les événements F1
      const f1Candidates = (epg || [])
        .filter((p) => {
          const titleMatch =
            p.title && 
            (p.title.toLowerCase().includes("formule 1") ||
            p.title.toLowerCase().includes("f1") ||
            p.title.toLowerCase().includes("grand prix"));

          // Pour les événements F1, faire correspondre par le nom de l'événement et l'heure
          const eventName = ev.title.toLowerCase();
          const fpMatch = eventName.includes("fp1") && p.title.toLowerCase().includes("essais libres 1");
          const fp2Match = eventName.includes("fp2") && p.title.toLowerCase().includes("essais libres 2");
          const qualiMatch = eventName.includes("qualifying") && p.title.toLowerCase().includes("qualificatif");
          
          // Match temporel approximatif (jusqu'à 2h de différence)
          const timeMatch = near(ev.start, p.start, 120);

          return titleMatch && timeMatch && (fpMatch || fp2Match || qualiMatch || true);
        })
        .sort(
          (x, y) =>
            Math.abs(tms(x.start) - tms(ev.start)) -
            Math.abs(tms(y.start) - tms(ev.start))
        );

      // Collecter toutes les chaînes uniques où l'événement est diffusé
      if (f1Candidates.length > 0) {
        const channels = [...new Set(f1Candidates.map((c) => c.channel))];
        ev.broadcasters = channels;
        console.log(
          `F1 event matched: ${ev.title} on ${channels.join(", ")}`
        );
      } else {
        // Pour les événements F1 sans correspondance dans l'EPG, ne pas assigner de diffuseur par défaut
        // mais laisser un tableau vide pour que l'interface puisse le gérer correctement
        ev.broadcasters = [];
        console.log(
          `F1 event not matched in EPG: ${ev.title}, no default broadcasters assigned`
        );
      }
    }

    // Fallback diffusuer par défaut
    if (!chan) {
      if (comp === "Serie A") chan = "DAZN";
      else if (comp === "Ligue 1")
        chan = isSat17Paris(ev.start) ? "beIN SPORTS 1" : "Ligue 1+";
    }

    // Ajouter l'événement au résultat
    if (ev.sport === "f1") {
      // Pour les événements F1, utiliser ev.broadcasters déjà défini
      out.push({
        uid: ev.uid,
        title: ev.title,
        start: ev.start,
        end: ev.end,
        sport: ev.sport,
        competition: comp,
        home: ev.home,
        away: ev.away,
        broadcasters: ev.broadcasters || [],
      });
    } else {
      // Pour les autres sports, utiliser le diffuseur trouvé via les équipes
      out.push({
        uid: ev.uid,
        title: ev.title,
        start: ev.start,
        end: ev.end,
        sport: ev.sport,
        competition: comp,
        home: ev.home,
        away: ev.away,
        broadcasters: chan ? [chan] : [],
      });
    }
  }

  return out;
}
}

// Mode CLI pour debug ou utilisation individuelle
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  (async () => {
    const ymd = process.argv[2];
    if (!/^\d{8}$/.test(ymd || "")) {
      console.error("Usage: node scripts/merge.js YYYYMMDD [--keep]");
      process.exit(1);
    }

    // Lit les fichiers JSON depuis disque
    const pData = "public/data";
    const pConf = "config";

    const ics = await tryRead([
      path.join(pData, `ics_${ymd}.json`),
      path.join(pData, `ics-${ymd}.json`),
    ]);
    const epg = await tryRead([
      path.join(pData, `epg_${ymd}.json`),
      path.join(pData, `epg-${ymd}.json`),
    ]);
    const teams = await tryRead([path.join(pConf, "teams.json")]);

    const merged = await mergeData(ics, epg, teams, ymd);

    // Dossier sortie
    await fs.mkdir(pData, { recursive: true });

    const outFile = path.join(pData, `progs_${ymd}.json`);
    await fs.writeFile(outFile, JSON.stringify(merged, null, 2), "utf-8");

    console.log(`✅ Merge completed (${merged.length} events)`);
    console.log(`📁 Wrote ${outFile} (${merged.length} events)`);

    // Gestion --keep éventuelle pour nettoyage dans pipeline externe
  })().catch((e) => {
    console.error(e.message || String(e));
    process.exit(1);
  });
}
}
